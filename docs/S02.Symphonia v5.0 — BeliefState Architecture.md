# S02.Symphonia v5.0 â€” BeliefState Architecture: Vestibular Fusion, Regimes, and Actionâ€“Reaction Readiness

**series:** S02
**version:** v5.0 (architecture)
**status:** proposal â†’ canon candidate
**scope:** Sensor fusion + interpretation layers (L0â€“L3), not motor control implementation yet
**goal:** Build a *vestibular/proprioceptive* â€œbelief stateâ€ that is truthful under missing data and supports future pulse/BEMF control.

---

## 1) Core idea

Symphonia must not only detect *movement*, but maintain a continuously updated internal **belief** about what is happening to her body:

* *best estimate* (what we think is happening)
* *uncertainty* (how sure we are)
* *regime* (what kind of sensing environment weâ€™re in)

This enables:

* robust interpretation with sparse events
* principled â€œcolorâ€ (confidence/resolution)
* correct transitions from passive sensing â†’ active actuation

---

## 2) Three kinds of truth

We explicitly separate:

1. **Event truth (L0):** â€œsomething happenedâ€ (never wrong, no meaning)
2. **Displacement truth (L1.5 / MDI):** â€œnet pose changedâ€ (good at t0, weak at absolute Î¸0)
3. **Rotation truth (L2/L3):** â€œI rotated through timeâ€ (needs continuity, yields Î¸Ì‚/rpm/dir)

**Rule:** These truths must never be collapsed into one number without an uncertainty label.

---

## 3) BeliefState v5.0 (single data contract)

### 3.1 State fields (conceptual)

At time (t), maintain:

#### A) Kinematics (best estimates)

* ( \hat{\theta}(t) ) : absolute virtual angle estimate (available in HIGH regime)
* ( \hat{\omega}(t) ) : angular velocity estimate (when stable)
* ( \hat{d}(t) ) : displacement since origin (MDI-first, refined by L2)

#### B) Origins (two-phase)

* ( O_t ): origin time (from MDI latch/confirm)
* ( O_\theta ): origin angle (committed when L2 supports it)

#### C) Uncertainty / color

* ( \sigma_\theta(t) ) or `conf_theta`
* `conf_disp` (MDI conf/acc)
* `conf_dir` (direction confidence)

#### D) Observability metrics (must be first-class)

* `ev_rate` (events/sec or events/window)
* `ev_win` (events in MDI window)
* `coherence` (pool-change coherence, valid_rate, tremor_score)
* `gap_age` (time since last meaningful evidence)

#### E) Regime tag (see Â§4)

* `REGIME âˆˆ {LOW_RATE, MID_RATE, HIGH_RATE}`

#### F) Traceability (why we believe it)

* `source_theta âˆˆ {none, L2_tiles, fused}`
* `source_origin âˆˆ {MDI, L2_commit}`
* `recon_allowed âˆˆ {true,false}`

---

## 4) Regime model (the â€œvestibular organâ€)

### 4.1 Why regimes

When events are sparse, fine kinematics is mathematically impossible.
So we do not â€œfailâ€; we **switch interpretation strategy**.

### 4.2 Regime definitions (example thresholds; tune later)

Let (r_E) = events/sec, and (n_W) = events in MDI window.

* **LOW_RATE:** (n_W < 5) or (r_E < R_1)
  â†’ latch/confirm; do not reconstruct; displacement-only truth
* **MID_RATE:** moderate evidence
  â†’ integrate displacement + early direction hints; cautious candidates
* **HIGH_RATE:** stable continuous evidence
  â†’ L2 dominates; Î¸Ì‚, rpm, direction lock reliable

### 4.3 Regime outputs (â€œcolorâ€)

Each regime defines what can be claimed:

| Regime    | Claims allowed                  | Color meaning                    |
| --------- | ------------------------------- | -------------------------------- |
| LOW_RATE  | â€œI was displacedâ€, O_t, rough Î” | low resolution, high honesty     |
| MID_RATE  | displacement + likely direction | medium resolution, growing trust |
| HIGH_RATE | Î¸Ì‚, Ï‰, LOCKED dir, movement     | high resolution, high trust      |

---

## 5) Fusion policy (how layers stack)

### 5.1 O(t0) and O(Î¸0) separation

* **O(t0)**: comes from MDI latch/confirm (fast, robust)
* **O(Î¸0)**: committed later from L2 tiles/cycles (slow, precise)

This matches biology: you feel â€œI movedâ€ before you know â€œexactly where I am.â€

### 5.2 â€œColor overlayâ€

We treat L2 not as replacement but as *refinement*:

* MDI provides displacement confidence even when Î¸Ì‚ is unavailable.
* L2 provides absolute angle and direction lock when stable.

**Fusion principle:** never override a high-confidence state with lower-confidence data.

---

## 6) Reconstruction rules (missing film)

We allow reconstruction only when:

* `REGIME == HIGH_RATE`
* coherence above threshold
* gap lengths below threshold

Otherwise:

* keep discontinuities explicit
* represent them as uncertainty growth (â€œdark framesâ€)

**Outcome:** Symphonia stays truthful rather than hallucinating angle.

---

## 7) Actionâ€“Reaction readiness (bridge to motor control)

v5.0 prepares for pulses/BEMF by defining a short-latency response channel:

#### 7.1 PulseResponse window

After an action pulse at time (t_p), measure:

* ( \Delta d ) from MDI within (t_p + 20..200ms) (fast proprioceptive reaction)
* coherence change (did the body respond consistently?)
* later: L2 confirmation (did it become rotation?)

#### 7.2 Control implication (future)

* Use MDI as **fast feedback** for â€œdid my pulse do anything?â€
* Use L2 as **slow confirmation** for â€œdid it become sustained motion?â€

This supports your â€œbow-and-arrow/BEMFâ€ vision:

* pre-load / pulse = action
* early MDI = immediate reaction
* later L2 = energy transfer validation

---

## 8) v5.0 mapping to existing v0.4.x reality (grounding)

Current assets already implement major pieces:

* L0: Event24 sensing
* L1: PhysicalActivityState
* L1.5: MDI latch/confirm, O_t
* L2/L3: tiles â†’ MovementBody, Î¸Ì‚ and direction lock (HIGH_RATE)

v5.0 does not discard these; it formalizes them into one BeliefState contract.

---

## 9) v5.0 Definition of Done (architecture)

* BeliefState contract agreed and documented
* Regime tag present and driven by ev_rate/coherence
* O(t0) from MDI and O(Î¸0) from L2 commit are separate and visible
* Uncertainty/color fields are first-class
* Reconstruction allowed only in HIGH_RATE
* Clear â€œactionâ€“reactionâ€ observation window defined for future motor control


## S02.Symphonia v5.0.1 â€” BeliefState JSON Schema (Canonical Contract)

**doel:** Ã©Ã©n waarheid over *wat Symphonia denkt dat er met haar lichaam gebeurt*, inclusief onzekerheid en regime
**status:** architectuur-canon (implementatie kan incrementeel)

### 1) Identiteit & tijd

```json
{
  "t_wall_s": 0.000,
  "t_mono_s": 0.000,
  "frame_id": 0
}
```

### 2) Regime & observability (eerste-klas)

```json
{
  "regime": "LOW_RATE | MID_RATE | HIGH_RATE",
  "observability": {
    "ev_rate_hz": 0.0,
    "ev_win": 0,
    "coherence": 0.0,
    "tremor": 0.0,
    "gap_age_s": 0.0
  }
}
```

**Betekenis:** bepaalt *wat* je mag claimen en *hoe* je integreert.

### 3) Origins (twee-fase)

```json
{
  "origin": {
    "t0_s": null,
    "theta0_deg": null,
    "source_t0": "MDI | L2_COMMIT | null",
    "source_theta0": "L2_COMMIT | null",
    "confidence": 0.0
  }
}
```

### 4) Displacement (MDI-dominant)

```json
{
  "displacement": {
    "delta_deg": 0.0,
    "delta_conf": 0.0,
    "micro_acc": 0,
    "micro_step_deg": 10.0,
    "latch": {
      "set": false,
      "age_s": null,
      "confirmed": false,
      "reason": "MDI_LATCH | MDI_TRIGGER | MDI_LATCH_DROPPED | null"
    }
  }
}
```

### 5) Rotation & kinematics (L2/L3)

```json
{
  "rotation": {
    "theta_hat_deg": null,
    "omega_dps": null,
    "direction": "CW | CCW | UNDECIDED",
    "dir_conf": 0.0,
    "total_cycles_physical": 0.0,
    "source": "L2_TILES | NONE"
  }
}
```

### 6) Uncertainty / â€œkleurâ€

```json
{
  "uncertainty": {
    "sigma_theta_deg": null,
    "conf_theta": 0.0,
    "conf_disp": 0.0,
    "conf_dir": 0.0
  }
}
```

### 7) Reconstruction policy

```json
{
  "reconstruction": {
    "allowed": false,
    "reason": "LOW_RATE | GAP_TOO_LARGE | COHERENCE_LOW | HIGH_RATE_OK"
  }
}
```

### 8) Traceability (waarom geloven we dit?)

```json
{
  "trace": {
    "theta_source": "NONE | L2_TILES | FUSED",
    "disp_source": "MDI",
    "notes": ""
  }
}
```

---

## Regels (kort en bindend)

* **LOW_RATE:** geen reconstructie; MDI mag O(t0) zetten; Î¸Ì‚ blijft null.
* **MID_RATE:** displacement + vroege richting *mag*, maar zonder LOCK.
* **HIGH_RATE:** L2 domineert; Î¸Ì‚/Ï‰/LOCKED toegestaan; O(Î¸0) commit.
* **No hallucination:** nooit Î¸Ì‚ invullen zonder HIGH_RATE.
* **Onzekerheid is data:** conf/sigma altijd bij claims.

---

## Waarom dit werkt voor jouw doel

* Je krijgt **diepte + kleur**: *wat* en *hoe zeker*.
* Missing frames blijven zichtbaar (geen geforceerde interpolatie).
* Klaar voor **actieâ€“reactie**: MDI geeft snelle respons; L2 bevestigt later.
* Architectuur stuurt tuning (regime-switch) i.p.v. losse thresholds.

---

## S02.Symphonia v5.0.2 â€” Regime Thresholds & Tuning Plan (LOW/MID/HIGH)

**doel:** objectief bepalen wanneer Symphonia alleen â€œvoeltâ€, wanneer ze â€œverplaatstâ€, en wanneer ze â€œrotatieâ€ mag claimen
**input:** jouw bestaande `live_origin_*.jsonl` logs + scoreboard observaties
**output:** stabiele thresholds + presets (hand_sensitive / bench_tolerant) + regressietests

---

## 1) Wat we moeten meten (en wat het betekent)

We definiÃ«ren 4 kernmaten die al in jouw systeem zitten of triviaal af te leiden zijn:

### A) Event-rate

* `ev_rate_hz` = events per seconde (of per tick-window)
* `ev_win` = events in MDI window (bv 200ms)

**Interpretatie:** hoeveel â€œfilmframesâ€ hebben we?

#### B) Coherentie Îº

Maak Ã©Ã©n scalar (0..1) uit:

* `valid_rate` (hoeveel events â€œzinvolâ€)
* `pool_changes_win` / `unique_pools_win`
* `tremor_score` (omgekeerd: hoge tremor = lage coherentie)

**Eenvoudige compositie (voorbeeld):**

* `coherence = clamp(0.5*valid_rate + 0.5*min(1, pool_changes_win/3) - 0.3*tremor_score)`

**Interpretatie:** is dit echte verplaatsing of flapper/jitter?

#### C) Gap ages

* `gap_age_s` (tijd sinds laatste betekenisvolle event)
* plus: `STOP_GAP_TIMEOUT` events (hard reset)

**Interpretatie:** hoe lang is de film onderbroken?

#### D) Bewijsniveau

* `mdi_disp_micro_deg` (Î¼)
* `mdi_conf_used` (inst/acc)
* `total_cycles_physical` (L2 waarheid)

**Interpretatie:** wat claimen we en hoe hard?

---

## 2) Regimes: definities die wÃ©l kloppen in de praktijk

We maken regimes expliciet, zodat je niet â€œper ongeluk encoder speeltâ€ met 3 events ğŸ˜„

### REGIME LOW_RATE

**Wanneer:** te weinig data voor kinematica.
**Voorwaarden (startwaarden):**

* `ev_win < 5`  **of** `ev_rate_hz < 20`
* **of** `coherence < 0.35`

**Claims toegestaan:**

* tactile activity (L1)
* MDI latch/confirm (L1.5)
* **O(t0)** mag
* **geen Î¸Ì‚, geen rpm, geen direction lock**
* reconstructie: **NO**

---

### REGIME MID_RATE

**Wanneer:** genoeg data voor *displacement+hint*, niet voor volledige rotatiezekerheid.
**Voorwaarden (startwaarden):**

* `ev_win >= 5` en `ev_rate_hz >= 20`
* `coherence >= 0.35`
* gaps niet te groot: `gap_age_s < 0.4`

**Claims toegestaan:**

* displacement sinds O (MDI)
* richting-hint *mag* (soft), maar **niet LOCKED**
* reconstructie: meestal NO (alleen micro-interpolatie met grote onzekerheid)

---

### REGIME HIGH_RATE

**Wanneer:** genoeg continuÃ¯teit voor echte L2-waarheid.
**Voorwaarden (startwaarden):**

* `ev_win >= 10` en `ev_rate_hz >= 50`
* `coherence >= 0.55`
* `gap_age_s < 0.2`
* en vooral: **tiles/cycles lopen** (L2 actief):

  * `total_cycles_physical` stijgt (of tile stream actief)

**Claims toegestaan:**

* Î¸Ì‚, Ï‰, rpm
* DIRECTION â†’ LOCKED
* MOVEMENT â†’ LOCKED
* reconstructie: **YES** (tussen ankers, met ÏƒÎ¸)

---

## 3) Tuning methode: niet gokken, maar kalibreren op logs

We gaan thresholds niet â€œzoekenâ€, maar **afleiden uit jouw echte data**.

### Stap 1 â€” Label je runs

Maak 3 labels op basis van wat jij fysiek deed:

* `NO_TOUCH / TREMOR`
* `HAND_STEP` (20â€“45Â°)
* `MULTI_ROT` (meerdere omwentelingen)

*(Dit kan zelfs handmatig per run in een notitie.)*

### Stap 2 â€” Bereken per run de distributies

Voor elk runlabel:

* median / p10 / p90 van `ev_rate_hz`, `ev_win`, `coherence`, `gap_age_s`
* en correlatie met:

  * PRE_MOVEMENT events (moet bij HAND_STEP)
  * LOCKED direction (moet pas bij MULTI_ROT)

### Stap 3 â€” Kies thresholds als â€œscheidslijnenâ€

* LOW/MID grens = waar NO_TOUCH stopt en HAND_STEP begint (min false positives)
* MID/HIGH grens = waar HAND_STEP stopt en MULTI_ROT begint (min premature LOCK)

**Praktisch:**

* gebruik p90 van NO_TOUCH als â€œruisplafondâ€
* gebruik p10 van HAND_STEP als â€œbewegingsvloerâ€
* thresholds tussen die twee

---

## 4) Presets (v5.0.2) die direct bruikbaar zijn

#### Preset: hand_sensitive

Voor jouw â€œeven met de hand testenâ€:

* `origin_step=15`
* `mdi_mode=C`
* regime thresholds iets lager:

  * LOWâ†’MID: `ev_win>=4` en `coherence>=0.30`
  * MIDâ†’HIGH: onveranderd streng (want rotatie blijft rotatie)

#### Preset: bench_tolerant

Voor validatie en minder false positives:

* `origin_step=30`
* `mdi_mode=B`
* LOWâ†’MID: `ev_win>=6`, `coherence>=0.40`
* MIDâ†’HIGH: `ev_win>=12`, `coherence>=0.60`, gaps klein

---

## 5) Acceptance tests (v5.0.2)

Dit zijn â€œregime testsâ€, niet alleen state tests.

#### Test A â€” micro tik/ruis

* regime blijft LOW
* geen PRE_MOVEMENT confirm (latch mag, maar dropt)
* reconstructie = false

#### Test B â€” hand-step 20â€“45Â°

* regime LOWâ†’MID (mag)
* PRE_MOVEMENT confirmed
* O(t0) gezet
* geen LOCKED direction
* Î¸Ì‚ mag null blijven

#### Test C â€” multi-rot

* regime â†’ HIGH
* total_cycles_physical stijgt
* Î¸Ì‚/Ï‰ actief
* direction LOCKED

---

## 6) EÃ©n slimme toevoeging (hoog rendement)

Voeg in dashboard/jsonl Ã©Ã©n regel toe:

* `REGIME=<LOW/MID/HIGH> reason=<ev_win/coh/gap/cycles>`

Dan zie je in Ã©Ã©n oogopslag waarom Symphonia iets wel/niet claimt.

---
