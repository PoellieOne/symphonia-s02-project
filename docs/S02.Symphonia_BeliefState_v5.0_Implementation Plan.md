## C0 — Wat we nu gaan maken (1e bouwstap)

### **Een Execution-layer “Action Gate”**

Een klein stuk uitvoerende logica dat:

* **alleen** uitvoert wanneer de semantiek het *toelaat* (via de projectie, niet als opdracht)
* **terugvalt** zonder drama
* **logt** in heldere, niet-semantische termen

Denk aan: een **gate** vóór torque/commutation/lock-gedrag.

Dit is het perfecte brug-object:

* technisch nuttig
* state-machine-achtig toegestaan (C)
* semantisch veilig (A+B)

---

## C1 — De minimale states (uitvoering, geen waarheid)

We houden dit expres klein:

1. **IDLE**
   Motor doet niks (of safe-hold), maar blijft observeren.

2. **OBSERVE**
   Motor leest pipeline (MovementBody / Compass / OriginTracker outputs) en verzamelt stabiliteitssignalen.

3. **ARMED**
   Uitvoering *mag* starten als er “KNOWING-projectie” aanwezig is (niet omdat BeliefState het zegt, maar omdat het verdedigbaar is).

4. **ACTIVE**
   Torque/commutation/lock-control loopt.

5. **FALLBACK**
   We stoppen/ontkoppelen netjes, resetten context, terug naar OBSERVE of IDLE.

**Belangrijk:** deze states zijn **execution**. Ze heten niet “Knowing” of “Bodyment”. Geen semantische woorden in de state-namen.

---

## C2 — Ingangen naar de gate (wat we “lezen”)

We gebruiken wat jullie al hebben in S02:

* **MovementBody / CompassSnapshot** (richting, rpm, coherentie-velden)
* **OriginTracker** (lock-status / coherentie, origin-consistentie)
* Optioneel: “quality” signalen uit Tiles/Cycles (als beschikbaar)

De gate vraagt niet: “is dit waar?”
De gate vraagt: “is uitvoeren nu **veilig/zinvol** gegeven wat er verschijnt?”

---

## C3 — Projectie toepassen volgens B (zonder semantisch lek)

We laten BeliefState (als betekenislaag) niet “commands” geven.

We doen dit:

* **CHANGE-projectie** → “we zien afwijking” → gate blijft OBSERVE of gaat FALLBACK als ACTIVE instabiel wordt
* **RHYTHM-projectie** → “er is cadans” → gate kan ARMED worden (maar hoeft niet)
* **BODYMENT-projectie** → “dragend genoeg” → gate mag ACTIVE *proberen*
* **KNOWING-projectie** → “handelen verdedigbaar” → gate mag ACTIVE *toestaan*

Maar: **Execution beslist zelf**. Altijd.

---

## C4 — Logging die later goud waard is (heel concreet)

We loggen uitsluitend uitvoerings-taal, nooit waarheidstaal.

Voorbeeld events:

* `GATE: enter OBSERVE reason=<...>`
* `GATE: arm source=<signals>`
* `GATE: activate mode=<commutation/hold/...>`
* `GATE: fallback reason=<lost_coherence / lost_rhythm / timeout / safety>`
* `GATE: inhibit reason=<insufficient_context>`

En 1 regel die je later zó blij maakt:

* `GATE: decision basis=<fields>`
  (alleen veldnamen/waarden, geen interpretatie)

Dit maakt testen super: jij kunt in logs zien *waarom* iets gebeurde, zonder dat het systeem deed alsof het “wist”.

---

## C5 — Wat ik nu van jou nodig heb (maar ik ga niet treuzelen)

Ik ga meteen door met een **concreet skeleton** (pseudocode + integratiepunten) voor jullie Python realtime pipeline óf Core0-side — maar om het in één keer raak te doen, kies ik de meest waarschijnlijke eerste locatie:

### Mijn default keuze:

**PC-side realtime pipeline** (waar MovementBody/OriginTracker samenkomen), omdat:

* sneller itereren
* beter loggen
* minder flash/loop-risico

Als jij liever direct op ESP32/Core0 zit, kan ook — maar PC is de snelste winst.

---

## C6 — Volgende deliverable (nu meteen, als jij “go” zegt)

Ik schrijf als volgende stap:

1. **`action_gate_v0_1.py`** (skeleton)
2. Een mini “integration recipe”: waar in `live_symphonia_v2_0.py` (of equivalent) je hem inhaakt
3. Een logging schema dat matcht met jullie event-mentaliteit

Zeg alleen:

* **“PC”** (default)
  of
* **“Core0”**
