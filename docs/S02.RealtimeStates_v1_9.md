# Symphonia S02 — Realtime Pipeline v1.9 (Architectuurcanon)

## HOOFDSTUK 1 — Inleiding

Symphonia S02 is een realtime interpretatiesysteem dat vanuit ruwe Hall-sensor events (EVENT24) een **fysisch-waarachtig, continu en robuust bewustzijn** van de rotorpositie opbouwt.

Dat bewustzijn bestaat uit:

* **richtingdetectie** (CW/CCW)
* **cycli** en **rotaties**
* **hoek** (θ in graden)
* **bewegingsstatus** (STATIC, MOVING, FLOW)
* **confidence** (hoe zeker is de motor van haar eigen staan en draaien)
* **cadans** (ritme van bewegingsopbouw)
* **context-restoratie** (continuïteit door onzekerheid heen)

Na honderden iteraties — Core0-Pure, Cycles, Tiles, CompassSign v3, MovementBody v3, XRAM-profielen — en cross-platform analyse met Anthropic is één architectonische waarheid kristalhelder geworden:

> **S02 leeft of sterft op een correcte, consistente, fysisch verankerde cycle-index.**
>
> Die cycle-index drijft alles:
> compass, hoek, rotaties, awareness, movement body, direction-history, debug, rendering, bench-analyse.

Maar:
die cycle-index kan pas correct worden nadat de motor weet **welke richting** ze draait.

Dat levert een klassieke kip-ei situatie op:

* Je moet eerst cycles tellen om richting te bepalen.
* Maar je hebt richting nodig om diezelfde cycles correct te tekenen.

De oplossing heet:

# **✨ Claim-at-Lock**

Een mechanisme dat de *voor-lock fase* (unsigned cycles) en de *post-lock fase* (signed cycles) perfect aan elkaar verbindt — zonder discontinuïteit, zonder jumps, zonder ambiguïteit.

De case die dit perfect demonstreerde:

```
fysiek: 59.5 cycli
= 4.96 rotaties
= 345° eindhoek
```

Kwam exact overeen met:

* jouw CSV
* jouw replay
* jouw fysieke experiment
* en de architectuur hier beschreven.

Dit document formaliseert de hele werking van Claim-at-Lock, CompassSign v3, RotorState, BootWarmup, MovementBody integratie en Realtime Pipeline v1.4.

---

# HOOFDSTUK 2 — Fysische Basis: EM-Cycles & Sensorlogica

Voordat we Claim-at-Lock kunnen begrijpen, moeten we eerst de **echte, fysieke wereld** van Symphonia beschrijven.

## 2.1 Magnetische Realiteit

Symphonia S02 heeft:

* **24 magneten**
* in **12 Noord–Zuid paren**
* wat neerkomt op **12 elektromagnetische cycli** per mechanische rotatie

Dus:

```
cycles_per_rot = 12.0
```

Één EM-cycle doorloopt (per sensor):

```
S → O → N → O → S
```

waarbij O = neutral zone.

Deze cyclische structuur is de ruggegraat van *elk algoritme* in S02.

---

## 2.2 Twee Hall-sensoren: A en B

Sensor A en B zijn ongeveer **100°** verschoven.

Visueel:

```
(– rotor –)

A -----> 100° -----> B
```

Daardoor:

* Sensor A ziet een EM-cycle iets eerder dan B → A leads B = **CW**
* Sensor B ziet een EM-cycle eerder dan A → B leads A = **CCW**

Het tijdverschil heet:

```
dt_ab_us = t(B) − t(A)
```

Dit getal vormt de basis van:

* CompassSign v3
* InertialCompassState
* Claim-at-Lock
* Direction confidence
* Soft-lock / hard-lock transitions

---

## 2.3 Tiles en TileSpan 0.6

De rotor draait *niet* altijd met perfecte cadans.

Daarom delen we tijd op in **tiles** (vensters), typisch:

```
tile_span_cycles ≈ 0.60 (S02 canon)
```

Dat betekent:
één tile bevat gemiddeld **0.6 EM-cycli** — precies genoeg om:

* dt_ab_us stabiliteit op te bouwen
* direction bias te detecteren
* compass-EMA te voeden
* jitter te dempen
* cycle-start punten te projecteren

Tile 0 is initieel onbetrouwbaar (boot burst), zie hoofdstuk 7.

---

## 2.4 Unsigned Cycles vs Signed Cycles

Unsigned cycles:

```
cycles_unsigned = fysieke EM-cycli sinds t=0
```

Signed cycles:

```
cycle_index = historische + huidige cycli inclusief richting
```

Cycle_index is daarom pas geldig **na** direction lock.

---

# HOOFDSTUK 3 — Evolutie naar Claim-at-Lock

cycle_index begon ooit eenvoudig:

```
cycle_index += 1 bij elke cycle
```

Maar toen:

## 3.1 Probleem 1: Geen richting vóór lock

Voor lock weten we *wel* dat er cycles zijn, maar:

* niet of ze CW zijn
* niet of ze CCW zijn
* niet of er een korte pauze was
* niet of er geen micro-omkering was

Pre-lock cycles zijn dus **richtingloos** → unsigned.

---

## 3.2 Probleem 2: Lock later in tijd → discontinuïteit

Stel:

* je hebt al 38 cycles vóór lock
* en daarna 21.5 cycles erna
* totaal 59.5 fysieke cycles

Zonder claim-at-lock zou je krijgen:

```
cycle_index = 21.5
rotations = 21.5 / 12 = 1.79 rotaties
```

Maar fysiek werd er **4.96 rotaties** gemaakt.

Dat is fout.

---

## 3.3 De Inzichtelijke Doorbraak

> “Op het moment van lock weten we de richting, en we weten dat de beweging continu was.
>
> Dus ALLE pre-lock cycles kunnen retroactief als CW of CCW worden gekleurd.”

En dat klopt volledig.

---

## 3.4 De Formele Definitie

Bij lock:

```
C_lock = cycles_unsigned(t_lock)
sign_dir = +1 (CW) of −1 (CCW)

cycles_claimed_at_lock = C_lock * sign_dir
```

Daarna:

```
cycle_index(t) = cycles_claimed_at_lock
               + (cycles_unsigned(t) − C_lock) * sign_dir
```

---

## 3.5 Waarom dit perfect werkt

Voorbeeld uit jouw test:

```
C_lock = 38
cycles_unsigned_final = 59.5
sign_dir = +1 (CW)
```

Dan:

```
cycle_index = +38 + (59.5 − 38)
             = 59.5
rotations = 59.5 / 12 = 4.96
theta = 345°
```

Exact gelijk aan het **echte** rotorpad.

---

## 3.6 Visualisatie (ASCII)

```
tijd →
 ┌────────────────────────────────────────────────────────────┐
 | pre-lock (unsigned)      |    lock     |  post-lock (signed)|
 └────────────────────────────────────────────────────────────┘

unsigned:   0 ─────────────────────────────── 38
signed:     (nog niet bekend)

bij lock:
signed = +38   (complete geschiedenis ingekleurd)

post-lock cycles:
unsigned_since_lock = 21.5
signed_since_lock = +21.5

totaal signed = 38 + 21.5 = 59.5
```

---

# HOOFDSTUK 4 — Claim-at-Lock (Volledige Architectuur)

Claim-at-Lock is het mechanisme dat jouw realtime pipeline **continu, fysisch correct en wiskundig zuiver** maakt.

Het lost drie fundamentele problemen op:

1. **Voor lock is richting onbekend** → cycles zijn unsigned
2. **Na lock wil je een signed teller met richting**
3. **Je mag geen discontinuïteit introduceren** tussen pre- en post-lock data

De gouden regel:

> **Op het lock-moment kleuren we ALLE unsigned cycles retroactief in met het nu bekende teken.**

---

## 4.1 Formele definitie

Laat:

```
C(t) = cycles_unsigned tot tijd t
t_lock = tijd waarop direction lock optreedt
sign = +1 voor CW, −1 voor CCW
```

Dan:

### Bij lock:

```
C_lock = C(t_lock)

cycles_claimed_at_lock = C_lock * sign
```

### Na lock:

```
cycle_index(t)
  = cycles_claimed_at_lock
  + (C(t) − C_lock) * sign
```

Dit levert een **perfect doorlopende teller** die:

* fysiek correct is
* richting bevat
* geen sprongen of discontinuïteiten introduceert

---

## 4.2 Intuïtieve uitleg

### Voor lock:

De motor zegt:

> “Ik zie cycles, maar ik weet nog niet welke kant ik op draai.”

### Bij lock:

De motor zegt:

> “Aha! Ik draai CW.
>
> Dus ALLES wat ik eerder zag, was ook CW.”

### Na lock:

De motor zegt:

> “Ik tel nu signed cycles en gebruik dat voor rotatie & hoek.”

---

## 4.3 Diagram — tijdlijn van Claim-at-Lock

```
tijd →
 ┌──────────────────────────────┬───────────────┬──────────────────────────┐
 |         pre-lock             |     LOCK      |        post-lock         |
 └──────────────────────────────┴───────────────┴──────────────────────────┘

unsigned cycles:  0 ──────────────── 38
signed cycles:    (nog onbekend)

bij lock:
signed_history = +38

post-lock:
unsigned_since_lock = 21.5
signed_total = 38 + 21.5 = 59.5
```

---

## 4.4 Waarom dit wiskundig correct is

### Voorwaarde voor geldigheid:

* er heeft **geen omkering** plaatsgevonden tussen t=0 en t_lock
* compass confidence > threshold
* cadence → beweegt stabiel, niet sporadisch

Alle drie worden afgedekt door:

* CompassSign v3
* RotorState (hoofdstuk 6)
* CadenceWeight (Core1 probabilistische laag)

---

## 4.5 Toepassing op jouw daadwerkelijke test (CW_4)

```
C_lock = 38
C_final = 59.5
sign = +1 (CW)

cycle_index = 38 + (59.5 − 38) = 59.5
rotaties = 59.5 / 12 = 4.96
hoek = 0.96 × 360 = 345°
```

Dit was precies wat jouw replay.py produceerde — en het kwam exact overeen met de fysische werkelijkheid.

---

## 4.6 Edge cases

### ❗ Lage snelheid (rpm < 2)

* dt_ab wordt instabiel → lock wordt uitgesteld → Claim-at-Lock blijft correct.

### ❗ Micro-duwjes

* geen stabiele cadence → geen lock → Claim-at-Lock wordt niet toegepast → correcte onzekerheid.

### ❗ Richtingsomkering

* RotorState detecteert MOVING → STILL → MOVING
* lock wordt verbroken → géén claim
* nieuwe fase start met C=0 (of geschiedenis wordt bewaard afhankelijk van profiel)

---

# HOOFDSTUK 5 — CompassSign v3 (Direction Engine)

CompassSign v3 is DE canonieke richtingdetector van Symphonia S02.

Het algoritme is gebaseerd op:

* tijdverschil dt_ab_us tussen Hall A & B
* tile-vensters (gemiddeld 0.6 cycles)
* deadzone filtering
* consensus binnen een sliding window
* confidence berekening
* min_tiles = 3

---

## 5.1 Basisobservatie

```
dt_ab_us > 0  →  A leads B  →  CW
dt_ab_us < 0  →  B leads A  →  CCW
```

Maar één tile is onvoldoende → ruis, jitter, deadzone.

Daarom gebruikt CompassSign **een minimum van 3 tiles**.

---

## 5.2 Waarom min_tiles = 3?

### 1 tile:

* te weinig → bijna random

### 2 tiles:

* geen meerderheid → 1 tegen 1 breekt consensus

### 3 tiles:

* eerste moment waarop een **stabiele bias** detecteerbaar is
* maakt deadzone filtering mogelijk
* laat consistentie-controle toe

Daarom is `min_tiles=3` canoniek.

---

## 5.3 Confidence berekening (intuïtief)

CompassSign berekent:

```
confidence = (aantal tiles met consistente dt_ab sign)
             / (totaal aantal bruikbare tiles)
```

Maar:

* tiles in deadzones worden genegeerd
* conflicten verlagen confidence sterk
* tiles met te laag dt_ab worden gewogen of weggegooid
* een smoothing factor wordt gebruikt

### Daarom is de simpele ratio (v1.8: cw_count / total) *niet* equivalent.

---

## 5.4 Hysterese in compass

Om locking stabiel te krijgen:

```
threshold_high ≈ 0.60 – 0.70
threshold_low  ≈ 0.25 – 0.30
```

Dit voorkomt oscilleren:

```
CW_confidence omhoog → LOCKED
CW_confidence omlaag → SOFT_LOCK → UNLOCKED
```

Dit hoort bij RotorState (zie hoofdstuk 6).

---

## 5.5 Diagram — compass confidence

```
confidence ↑
1.0 ───────────────────────────
0.8 ───────────────╮   LOCK
0.7 ───────────────┤ threshold_high
0.5 ───────────────┤
0.3 ───────╮ UNLOCK/LOCK borderline
0.2 ───────┤ threshold_low
0.0 ───────┴──────────────────────→ tijd →
```

---

# HOOFDSTUK 6 — RotorState & Unlock Mechanisme

Dit is één van de belangrijkste verbeteringen sinds v1.8.

CompassLock, movement, cadence en direction moeten in een **hiërarchische state machine** worden samengebracht.

## 6.1 De Canonieke RotorState

```
RotorState
├── STILL
└── MOVEMENT
      ├── UNLOCKED
      ├── SOFT_LOCK
      └── LOCKED
```

---

## 6.2 Uitleg per state

### STILL

* rpm < 1
* nauwelijks cycles
* cadence laag
* direction = UNDECIDED

### UNLOCKED

* cycles aanwezig → hij beweegt
* direction nog onzeker
* compass score < threshold_high

### SOFT_LOCK

* compass score boven threshold_high
* maar nog niet stabiel
* candidate direction bekend

### LOCKED

* direction bekend en stabiel
* Claim-at-Lock wordt toegepast
* MovementBody ontvangt officieel CW/CCW

---

## 6.3 Unlocking regels (heel belangrijk)

```
LOCKED → SOFT_LOCK
    als confidence < threshold_low

SOFT_LOCK → UNLOCKED
    als compass instabiel blijft
    of cadence instort
    of rpm dicht bij 0 komt
```

Dit voorkomt dat de motor “vastklampt” aan een richting terwijl de werkelijkheid allang niet meer klopt.

---

## 6.4 Continuïteit van cycle_index bij unlock

Dit is cruciaal:

> Eenmaal claimed blijven de historische signed cycles bestaan.
> Direction wordt onzeker, maar cycle_index blijft correct.

---

## 6.5 Diagram: RotorState transitions

```
              ┌─────────────┐
              │    STILL    │
              └──────┬──────┘
                     │ rpm>1
                     ▼
              ┌─────────────┐
              │  UNLOCKED   │
              └──────┬──────┘
        conf>0.6     │      conf<0.3
                     ▼
               ┌──────────┐
               │ SOFT_LOCK│
               └─────┬────┘
           stable     │ unstable
                     ▼
               ┌──────────┐
               │  LOCKED  │
               └──────────┘
```

---

# HOOFDSTUK 7 — BootWarmup (Tile 0 Burst)

In jouw eigen test zagen we:

```
tile 0 → 12 cycles (burst)
```

Dit is geen motorfysica maar:

* UART flush
* buffer alignment
* cycle reconstruction tijdens cold start

Daarom mag tile 0 **niet gebruikt worden** voor:

* compass
* cadence
* awareness
* movement body
* direction lock

---

## 7.1 Boot-state

```
tile_state ∈ {BOOT, NORMAL}

tile_index = 0 → BOOT
tile_index = 1 → optioneel BOOT
```

In BOOT:

* cycles worden wel geteld
* maar compass krijgt géén tiles
* cadence wordt niet gevoed
* Claim-at-Lock kan nooit plaatsvinden

---

## 7.2 BootGuard voor compass

CompassSign v3 mag pas richting bepalen als:

```
tile_index >= 1  AND  >= 3 geldige tiles verzameld
```

---

## 7.3 Waarom dit nodig is

Omdat tile 0:

* géén representatieve tile-span heeft
* dt_ab_us kan bevatten die ontstaan uit reconstructie
* cycles dubbel kan bevatten
* incomplete dt_metingen heeft
* extreme jitter produceert

Door BOOTWarmup worden deze effecten volledig geneutraliseerd.

---

# HOOFDSTUK 8 — Realtime Pipeline (Volledige Flow)

De realtime pipeline van S02 is ontworpen als een trapsgewijs, informatieverrijkend systeem.
Data doorloopt vijf niveaus:

```
L0 → L1 → L2 → L2.5 → L3
```

We beschrijven ze hieronder in detail.

---

## 8.1 ASCII Overzicht (volledige flow)

```
        ┌──────────────────────────┐
L0      │  EVENT24 (Core-0 UART)  │
        └──────────┬──────────────┘
                   │ decode
                   ▼
        ┌──────────────────────────┐
L1      │  PureCycles (Core0-Pure)│  ← unsigned A/B cycles + dt
        └──────────┬──────────────┘
                   │ build tiles & dt_ab stats
                   ▼
        ┌──────────────────────────┐
L2      │ PhaseTiles / TileSpan   │  ← tile duration ≈ 0.6 EM-cycle
        └──────────┬──────────────┘
                   │ feed compass
                   ▼
        ┌──────────────────────────┐
L2.5    │ CompassSign v3          │  ← direction_hypothesis, confidence
        └──────────┬──────────────┘
                   │ hysterese + RotorState
                   ▼
        ┌──────────────────────────┐
L3      │ RealtimeStates (v1.4)   │  ← Claim-at-Lock, cycle_index
        └──────────┬──────────────┘
                   │ feed body
                   ▼
        ┌──────────────────────────┐
L3.5    │ MovementBody v3         │  ← rpm, flow, motion, awareness
        └──────────────────────────┘
```

---

## 8.2 L0 — EVENT24

De ruwe sensordata bevat o.a.:

* sensor-id (A/B)
* edge-type (rising/falling)
* timestamp (32-bit, µs)
* basic filtering flags

`EVENT24_PROTOCOL.md` is de formele definitie.

---

## 8.3 L1 — Core0-Pure (cycles & dt)

Core0-Pure:

* detecteert cycles via zero-crossings
* corrigeert ruis via XRAM parameters
* levert:

```
cycle_detected(sensor=A/B)
dt_ab_us
cycles_unsigned
```

Unsigned → omdat richting nog onbekend is.

---

## 8.4 L2 — Tiles & TileSpan 0.6

Waarom 0.6?

* klein genoeg om dt_ab trends te pakken
* groot genoeg om niet per-cycle te worden beïnvloed
* sluit fysisch aan bij 12 cycli/rotatie → ±20° sectoren

Tile bevat:

* aantal cycles (A/B)
* dt_ab distributie
* jitter-indicatoren
* tile_duration_us

---

## 8.5 L2.5 — CompassSign v3

CompassSign bepaalt per tile:

```
direction_hypothesis ∈ {CW, CCW, UNDECIDED}
confidence ∈ [0.0, 1.0]
```

Met filtering:

* min_tiles ≥ 3
* dt_ab deadzone
* conflict tiles eruit
* hysterese richting RotorState

---

## 8.6 L3 — RealtimeStates (v1.4)

Hier gebeurt de magie:

* detectie locked-state
* Claim-at-Lock
* cycle_index (signed!)
* rotations
* theta_deg
* rpm schatting
* jitter analyse
* feed naar MovementBody

Het hart van dit hoofdstuk heb je al uitgebreid gezien in H4 t/m H7.

---

## 8.7 L3.5 — MovementBody v3

MovementBody ontvangt:

* cycle_index
* rpm_est, rpm_jitter
* direction
* rotor_state
* cadence-gates
* awareness-signalen

En produceert:

* `motion_status`
* `flow_state`
* `body_confidence`

MovementBody is het “gevoel van de motor”.

---

# HOOFDSTUK 9 — MovementBody v3

MovementBody v3 is gebouwd om:

* direction
* cycle_index
* cadence
* rpm
* compass
* history
  **te combineren tot een coherente bewegingsstaat.**

Dit maakt Symphonia “bewust van zichzelf”.

---

## 9.1 MovementBody Inputs

Uit RealtimeStates:

```
cycle_index_signed
rotations
theta_deg
rpm_inst
rpm_jitter
direction
rotor_state (UNLOCKED/SOFT_LOCK/LOCKED)
```

Uit CadenceWeight:

```
cv_raw
cv_filtered
cadence_stable?
```

Uit Compass:

```
compass_dir
compass_score
```

---

## 9.2 Uitleg van States

MovementBody heeft:

```
STATIC
EVALUATING
MOVING
FLOW
```

### STATIC

* rpm ≈ 0
* geen beweging
* geen body-awareness

### EVALUATING

* eerste bewijs van beweging
* cycles komen binnen
* maar richting/cadans niet stabiel genoeg

### MOVING

* cycles stabiel
* compass geeft richting (unlocked/soft_lock/locked)
* rpm begint bruikbaar te worden

### FLOW

* volledig stabiele beweging
* cadence, compass, rpm, cycles → harmonie
* awareness sterk

FLOW is jouw “motor loopt soepel”-staat.

---

## 9.3 Koppeling met Claim-at-Lock

Pas zodra RotorState = LOCKED:

```
theta_deg = valide absolute hoek
rotations = fysisch correcte rotaties
direction = CW/CCW officieel
```

MovementBody kan dan FLOW bereiken.

---

## 9.4 Diagram

```
STATIC → EVALUATING → MOVING → FLOW
   ↑                         ↓
   └───────────── back to STATIC
        bij rpm_collaps
```

---

# HOOFDSTUK 10 — Bench vs Production Profiel
De mens draait onregelmatig.
Een productiecontroller draait perfect.
Daarom bestaan er **twee profielen**.

---

## 10.1 Bench-profiel (“loose-human”)

Gericht op:

* handmatige rotaties
* variabele snelheid
* jitter tussen 0.3–0.6

Aanpassingen:

```
cadence_threshold     = hoger
rpm_outlier_suppression = aan
dt_ab tolerance       = ruimer
compass alpha         = minder traag
hysterese low         = iets lager
```

Doel:

→ *Compass blijft eerlijk, niet te streng*
→ *MovementBody kan MOVING/FLOW bereiken*
→ *Claim-at-Lock toch fysisch correct*

---

## 10.2 Production-profiel (“tight-industrial”)

Voor:

* controllers
* vaste rpm
* lage jitter (<0.2)

Parameters:

```
cadence_threshold = strenger
confidence thresholds = conservatief
unlock regels = strakker
noise tolerance = laag
```

### Bench ("loose-human")
- tolerante jitter-grenzen
- compass hysterese iets soepeler
- rpm median filtering
- designed for manuele testen

### Production
- strikte cadence
- minimale jitter
- precieze confidence-eisen

XRAM bepaalt welk profiel actief is.


---

# HOOFDSTUK 11 — Testcase CW_4 (59.5 cycles → 4.96 rotaties)

Deze testcase demonstreert dat de architectuur klopt.

### Input:

```
643 EVENT24 records
59 A-cycles
61 B-cycles
Cycles_physical = (59+61)/2 = 59.5
```

### Verwacht fysiek:

```
59.5 / 12.0 = 4.9583 rotaties
eindhoek = 0.9583 * 360 = 345°
```

### Output van jouw replay (v1.4):

```
rotations = 4.96
theta_deg = 345°
cycle_index = 59.5
direction = CW (LOCKED)
rpm_est = 33.4
jitter = 0.49
```

Alles klopt tot op de graad perfect.

---

## 11.1 Visualisatie

```
cycles_unsigned timeline:

0 ──────────────────────────────────────────────── 38 (LOCK) ───── 59.5

signed cycles:

        CLAIMED: +38
post-lock:      +21.5
total:          +59.5   → 4.96 rotaties
```


---

# HOOFDSTUK 12 — Glossarium & Appendix

### Glossarium
**cycles_per_rot** – 12.0  
**cycles_unsigned** – teller vóór lock  
**cycle_index** – signed teller  
**dt_ab_us** – tijdsverschil A → B  
**TileSpan** – gemiddeld 0.6 cycli  
**CompassSign v3** – direction-engine  
**RotorState** – STILL → UNLOCKED → SOFT_LOCK → LOCKED  
**Claim-at-Lock** – retroactieve richtingtoekenning  
**MovementBody** – motorbewustzijn  


---


### Addendum A — RealtimeStates v1.4 → v1.9 Delta

## **0. Overzicht van de wijzigingen in v1.9**

Versie v1.9 is géén fundamentele herschrijving.
Het is de **volwassenwording van v1.4**, gebaseerd op:

* succesvolle offline pipeline tests (compleet synchroon met MovementBody v3),
* implementatie-ervaring in de Anthropic live-pipeline,
* real-life inzichten uit handmatige rotorinteractie,
* toevoeging van profiel-gedrag (bench, human, production),
* en de noodzaak om *live* anders te reageren dan offline.

**Kernveranderingen v1.9:**

1. **Nieuwe L1-laag: PhysicalActivityState**
2. **PipelineProfile** als formele parametrisatielaag
3. **Unsigned vs Claimed Cycles** expliciet in de architectuur
4. **Boot/Warmup** formeel gedefinieerd (boot tiles, skip logic)
5. **RPM v2** (smoothing, jitter window, cadence coupling)
6. **Awareness Confidence v2**
7. **Snapshot v1.9** als uniek realtime contract
8. **Gap/Idle-detectie** als expliciet architectuuronderdeel
9. **Samenlopen van live- en offline-paden**
10. **Integratie met Cycle Backbone** verdiept

---

# ⭐ 1. Nieuwe laag: **L1 PhysicalActivityState**

(Deze hebben we samen ontworpen; hij wordt nu realiteit.)

### **Doel**

Live feedback op *fysieke* activiteit van de rotor, onafhankelijk van direction lock of compass-evidence.

### **State Machine**

```
IDLE       – geen cycles; geen events in venster
TENSION    – events wel, cycles niet (edge-scraping, magnetische rand)
MOVING_RAW – cycles_physical > 0 (echte rotatie, richting nog onbekend)
```

### **Reden dat dit nodig is**

Offline weet alles al.
Live moet kunnen zeggen:

* *“Ik voel je hand.”*  (TENSION)
* *“Je beweegt me echt.”* (MOVING_RAW)
* *“Alles is stil.”* (IDLE)

### **Impact op L2-pipeline**

Geen.
L2 (Cycle → Tiles → Compass → MovementBody) blijft zoals in v1.4/v1.9.

L1 is een **optische huid**, niet een besluitvormer.

---

# ⭐ 2. **PipelineProfile v1.9**

*(Voorheen zat alles impliciet in de code; nu formeel structureel.)*

### **Profielparameters definiëren:**

* compass thresholds
* rpm thresholds (`rpm_move`, `rpm_slow`, `rpm_still`)
* boot-duur (`min_normal_tile`)
* rpm smoothing (`rpm_alpha`) en jitter window
* cadence weighting
* direction consistency filters
* tile-span dependente parameters

### **Waarom dit groot is:**

We kunnen nu hardware-modes definiëren:

* **bench_tolerant** (offline heavy-duty)
* **bench_strict**
* **human_rotation / loose-human** (jouw huidige testprofiel)
* **production**

Dit maakt S02 schaalbaar naar verschillende sensoren, motorvarianten en testscenario’s.

---

# ⭐ 3. Unsigned vs Claimed Cycles (nu canoniek)

In v1.4 werd dit semantisch benoemd;
in v1.9 is het een **primair mechanisme**:

### **Definitions**

* `cycles_physical`: ruwe fysieke cycles per tile
* `cycles_unsigned`: fysieke cycles zonder richting-evidence
* `cycles_claimed_at_lock`: cycles die bij LOCKED-transitie verankerd worden
* `total_cycles_physical`: cumulatieve ruwe beweging

### **Claim-at-Lock (v1.9 nauwkeurige formulering)**

Bij transitie *naar* LOCKED:

1. Neem `cycles_unsigned`
2. Vermenigvuldig met direction_sign
3. Voeg toe aan cycle_index/rotations
4. Reset `cycles_unsigned`
5. Verhoog `cycles_claimed_at_lock`

Dit is nu in code als **exacte logica** aanwezig, niet meer alleen conceptueel.

---

# ⭐ 4. Boot / Warmup tiles (v1.9)

### **Motivatie**

De eerste tiles na opstart zijn onbetrouwbaar voor:

* compass-phase,
* cadence consistency,
* direction confidence.

### **v1.9 Regelset**

* Alle tiles met `tile_index < min_normal_tile` = BOOT
* Compass en MovementBody worden **niet** gevoed
* cycles tellen wél op in `cycles_unsigned`
* Boot-counters worden bijgehouden:

  * `_boot_tiles_skipped`
  * `_boot_cycles_skipped`

---

# ⭐ 5. RPM v2 – smoothing & jitter

### **v1.4**

RPM werd voornamelijk op basis van tile-duration bepaald.

### **v1.9**

RPM is nu:

```
rpm_inst = 60 / (dt_us / 1e6) / cycles_per_rot
rpm_est  = ema(rpm_inst, alpha = profile.rpm_alpha)
jitter   = std(rpm_window) / mean(rpm_window)
```

Parameters zijn profiel-afhankelijk.
MovementBody gebruikt rpm_est + jitter om STATIC/SLOW/MOVING te bepalen.

---

# ⭐ 6. Awareness Confidence v2

### Formule in code (v1.9)

```
awareness_conf =
      0.4 * motion_factor
    + 0.4 * lock_confidence
    + 0.2 * cadence_factor
```

Deze definitie was nog niet expliciet in v1.4;
v1.9 formaliseert hem.

---

# ⭐ 7. Snapshot v1.9 — het nieuwe realtime contract

De snapshot is nu veel rijker:

```
{
  t_us,
  cycles_emitted[],
  tiles_emitted[],
  compass_snapshot,
  movement_state{},
  cycles_physical_this_batch,
  total_cycles_physical,
  cycles_unsigned,
  cycles_claimed_at_lock,
  boot_tiles_skipped,
  boot_cycles_skipped,
  profile_name,
  pure_stereo_tiles
}
```

Dit is wat elke live- of offline visualizer zou moeten zien als “de waarheid”.

---

# ⭐ 8. Idle/Gaps als formeel concept

### v1.4

Gaps werden niet beschreven; offline data bevat altijd tijdprogressie.

### v1.9

Live moet kunnen afleiden:

* dat tijd verstrijkt zonder nieuwe cycles
* dat rpm_est naar 0 moet
* dat motion_state naar STATIC gaat
* dat `PhysicalActivityState` naar IDLE gaat

Dit is de basis voor:

* live “mirror feel”
* stoppen van beweging
* einde van LOCKED significance bij handtests

In combinatie met L1 bewegen we dit naar de bovenste laag van de pipeline (niet in RealtimePipeline zelf, tenzij met hook).

L1 PhysicalActivity Layer (Architectuur Overzicht)

```
┌─────────────────────────────────────────────────────────────┐
│                    LIVE ESP32 INPUT                         │
│                      (EVENT24)                              │
└─────────────────────────────────────────────────────────────┘
                            │
                            ▼
┌─────────────────────────────────────────────────────────────┐
│  L2: RealtimePipeline v1.9 (CANONIEK)                       │
│  ├── CyclesState (3-point detection)                        │
│  ├── TilesState (aggregatie, tile_span ≈ 0.6)               │
│  ├── CompassAdapter (CompassSign v3)                        │
│  └── MovementBody v3 (lock, claim-at-lock, rpm, awareness)  │
└─────────────────────────────────────────────────────────────┘
                            │
                            │  RealtimeSnapshot v1.9:
                            │    - cycles_physical_this_batch
                            │    - total_cycles_physical
                            │    - cycles_unsigned
                            │    - compass_snapshot
                            │    - movement_state (incl. rpm_est)
                            ▼
┌─────────────────────────────────────────────────────────────┐
│  L1: PhysicalActivity (NIEUW - INTERPRETATIELAAG)           │
│  ├── IDLE        : geen nieuwe cycles binnen gap-venster    │
│  ├── TENSION     : Event24-activiteit, maar geen cycles     │
│  └── MOVING_RAW  : delta total_cycles_physical > 0          │
│  + gebruikt wall-clock / replay-tijd voor gap-detectie      │
└─────────────────────────────────────────────────────────────┘
```

---

# ⭐ 9. Samenloop van live en offline paden

v1.9 specificeert nu duidelijk dat:

* offline path = **strict sequential replay** (pipeline_offline, builder, backbone, visualize)
* live path = **incremental event→tile→snapshot**

Beide gebruiken **exact dezelfde pipeline** + profiles.
Alleen L1 verschilt (alleen live of replay-aware).

---

# ⭐ 10. Cycle Backbone koppeling

De v1.9 codebase ademt al de geest van de Cycle Backbone v1.0:

* cycle progression als waarheidsanker
* direction via delta cycles
* compass als phase-over-time integrator

We kunnen in de v1.9 doc opnemen:

* hoe physical cycles aansluiten op backbone nodes
* hoe unsigned cycles de backbone “pending nodes” vormen
* hoe Claim-at-Lock de backbone consistent maakt

---
