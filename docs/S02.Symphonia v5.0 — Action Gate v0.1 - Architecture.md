# Action Gate v0.1 (Architectuur)

**Status:** Conceptueel, uitvoering-gericht, semantisch veilig
**Herkomst:** Afgeleid van A (Articulative Summary) + B (Belief→Action Bridge)
**Scope:** PC-side realtime pipeline (eerste implementatie)
**Doel:** Een minimale, robuuste execution-laag die “handelen” regelt zonder ooit “waarheid” te claimen.

---

## 1) Doel en bestaansreden

De **Action Gate** is een kleine execution-module die bepaalt:

* *wanneer* de uitvoerende laag mag activeren (torque/commutation/lock-acties),
* *wanneer* ze moet observeren of terugvallen,
* en *hoe* dit zichtbaar wordt in logs.

De Gate is er **niet** om te “weten”, maar om **veilig en eerlijk** te handelen aan de rand van wat fysiek mogelijk is.

---

## 2) Bindende scheiding: Betekenis vs Uitvoering

### 2.1 BeliefState (semantiek)

* articuleert (tijdelijk, herroepbaar)
* bezit geen macht
* geeft geen opdrachten

### 2.2 Execution (control)

* handelt deterministisch
* gebruikt states, timers, thresholds (in C toegestaan)
* bezit geen waarheid
* rapporteert observaties, geen claims

**Bindende regel:**

> **Geen execution-state of logbericht mag semantische woorden gebruiken als naam of autoriteit.**
> Dus geen: `KNOWING`, `BODYMENT`, `RHYTHM`, `TRUTH`, `STILL` als execution-labels.

---

## 3) Interface (conceptueel) — Inputs en Outputs

### Inputs (PC-side)

De Gate “leest” bestaande S02-signals (geen nieuwe waarheid):

* **Direction / RPM / coherence** (MovementBody / Compass-achtige outputs)
* **Lock/status/consistency** (OriginTracker-achtige outputs)
* **Quality/availability** (data-presence: cycles/tiles/staleness)

> Gate-inputs zijn **observaties** (velden/waarden), geen interpretaties.

### Outputs

De Gate produceert:

1. **Execution Mode** (toestaan/verbieden)

   * `ALLOW_ACTIVE` (uitvoering mag actief)
   * `HOLD_OBSERVE` (observeer)
   * `FORCE_FALLBACK` (veilig terugvallen)

2. **Execution State** (interne gate-state; zie §4)

3. **Log Events** (zie §7)

---

## 4) Minimale Gate-State machine (execution-only)

Deze states zijn **operationeel**, niet semantisch:

1. **IDLE**

   * Geen actie, safe posture.
   * Doel: beschikbaar zijn zonder te sturen.

2. **OBSERVE**

   * Verzamelt context uit pipeline-velden.
   * Doel: stabiliteit en continuïteit monitoren.

3. **ARMED**

   * Uitvoering *mag* starten zodra “beslisbaarheid” voldoende is.
   * Doel: klaarliggen zonder te forceren.

4. **ACTIVE**

   * Uitvoering is aan (torque/commutation/lock gedrag kan lopen).
   * Doel: handelen binnen guardrails.

5. **FALLBACK**

   * Veilige afbouw of reset van actie.
   * Doel: herstel naar OBSERVE/IDLE.

**Belangrijk:** de Gate is klein en mag “saai” zijn. Saai = betrouwbaar.

---

## 5) Overgangen (conceptueel) — zonder thresholds vast te leggen

We definiëren *wanneer* een overgang **type-matig** mag gebeuren, niet hoe numeriek.

### IDLE → OBSERVE

* Wanneer er actuele pipeline-inputs binnenkomen.

### OBSERVE → ARMED

* Wanneer er voldoende context is om *actief worden* te overwegen.
* Dit kan o.a. samenhangen met:

  * data-availability (niet stale)
  * richting/rpm/coherence aanwezig
  * OriginTracker-consistentie niet “broken”

### ARMED → ACTIVE

* Wanneer handelen **verdedigbaar** is volgens de bridge-houding:
  *Belief→Action projectie ondersteunt het, maar is geen command.*

### ACTIVE → FALLBACK

* Wanneer de execution-laag observeert dat actie niet langer houdbaar is:

  * coherentie verlies
  * lock-verlies
  * data-stale
  * safety event

### FALLBACK → OBSERVE (of IDLE)

* Na afbouw/reset.
* OBSERVE als er nog data komt, anders IDLE.

---

## 6) Projectie uit B (hoe semantiek context wordt, geen opdracht)

De Gate mag de volgende **projectie-soorten** gebruiken als contextlabels, maar **niet als state-namen**:

* CHANGE-projectie → “de situatie wijkt af / veranderend”
* RHYTHM-projectie → “er is herhaling/cadans”
* BODYMENT-projectie → “continuïteit lijkt gedragen”
* KNOWING-projectie → “handelen is nu verdedigbaar”

**Bindende regel:**

> De Gate mag projecties *wegen*, maar nooit *gelijkstellen aan waarheid*.

Praktisch in logs: projecties verschijnen als **“basis”** of **“context”**, nooit als “truth”.

---

## 7) Logging-taal (cruciaal voor debug en semantische hygiëne)

### 7.1 Log-principes

* Logs zijn **execution-observaties**
* Geen “ik weet”, geen “waar”, geen “zeker”
* Wel: “ik sta toe”, “ik val terug”, “ik zie verlies van signaal”

### 7.2 Minimale log events

* `GATE_ENTER state=<IDLE|OBSERVE|ARMED|ACTIVE|FALLBACK> reason=<token>`
* `GATE_DECISION state=<...> output=<ALLOW_ACTIVE|HOLD_OBSERVE|FORCE_FALLBACK>`
* `GATE_BASIS fields=<lijst met veldnamen en kernwaarden>`
* `GATE_FALLBACK reason=<token>`

### 7.3 Reason tokens (execution-neutraal)

Voorbeelden (niet limitatief):

* `reason=data_stale`
* `reason=coherence_drop`
* `reason=lock_lost`
* `reason=insufficient_context`
* `reason=safety_reset`
* `reason=armed_condition_met`

---

## 8) Acceptatiecriteria (wat “goed” betekent)

De Gate is geslaagd als:

1. **Semantische hygiëne**

   * Geen TRUTH-woorden in state-namen of claims in logs.

2. **Deterministisch gedrag**

   * Bij dezelfde inputs → dezelfde gate output/state transitions.

3. **Veilige fallback**

   * ACTIVE kan altijd veilig naar FALLBACK zonder “hang” of ambiguity.

4. **Debugbaarheid**

   * Elke overgang heeft een log-reason en “basis-fields”.

5. **Integratie-licht**

   * Gate kan worden ingehaakt zonder pipeline te herstructureren.

---

## 9) PC-side integratiepunten (conceptueel)

De Gate hoort te leven op de plek waar:

* MovementBody / Compass outputs
* OriginTracker outputs
* realtime tick/loop timing

samenkomen.

De Gate moet per tick:

* inputs lezen
* state update uitvoeren
* output (allow/hold/fallback) leveren
* loggen (bij transitions en beslissingen)

---

## 10) Verboden (expliciet)

De implementatie mag **niet**:

* BeliefState vervangen door Gate-states
* Gate-states benoemen met semantische TRUTH-labels
* logs laten klinken alsof het systeem “waarheid bezit”
* “handigheid” verkiezen boven traceerbaarheid in deze eerste versie

---

## 11) Resultaat

Na implementatie van Action Gate v0.1 op PC-side:

* hebben we een stevig uitvoeringsskelet
* kunnen we veilig experimenteren met “grenzen van het mogelijke”
* en blijft A+B intact als semantische fundering

---
